{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","web/js/main.js","main.js","node_modules/maquette/dist/maquette.js","node_modules/vdom-benchmark-base/lib/benchmark.js","node_modules/vdom-benchmark-base/lib/executor.js","node_modules/vdom-benchmark-base/lib/index.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","convertToVnode","node","children","h","key","map","BenchmarkImpl","container","b","this","projection","benchmark","maquette","NAME","VERSION","prototype","setUp","tearDown","update","render","dom","create","appendChild","domNode","document","addEventListener","vdom-benchmark-base","2","root","factory","define","amd","nodeName","createDom","updateDom","NAMESPACE_W3","NAMESPACE_SVG","NAMESPACE_XLINK","emptyArray","extend","base","overrides","result","Object","keys","forEach","same","vnode1","vnode2","vnodeSelector","properties","bind","toTextVNode","data","undefined","text","toString","appendChildren","parentSelector","insertions","main","item","Array","isArray","hasOwnProperty","push","missingTransition","DEFAULT_PROJECTION_OPTIONS","namespace","eventHandlerInterceptor","styleApplyer","styleName","value","style","transitions","enter","exit","applyDefaultProjectionOptions","projectorOptions","checkStyleValue","styleValue","setProperties","projectionOptions","propNames","propCount","propName","propValue","split","token","classList","add","classNames","classNameCount","j","className","styleNames","styleCount","type","lastIndexOf","oldPropValue","evt","target","apply","setAttributeNS","setAttribute","updateProperties","previousProperties","propertiesUpdated","previousValue","on","previousOn","remove","newStyleValue","oldStyleValue","findIndexOfChild","sameAs","start","nodeAdded","vNode","enterAnimation","nodeToRemove","exitAnimation","pointerEvents","removeDomNode","parentNode","removeChild","checkDistinguishable","childNodes","indexToCheck","parentVNode","operation","childNode","updateChildren","vnode","oldChildren","newChildren","oldChildrenLength","newChildrenLength","oldIndex","newIndex","textUpdated","oldChild","newChild","findOldIndex","addChildren","initPropertiesAndChildren","textContent","afterCreate","insertBefore","c","found","createTextNode","charAt","slice","id","createElementNS","createElement","previous","updated","newVNode","replaceChild","firstChild","afterUpdate","updateAnimation","createProjection","updatedVnode","selector","arguments","childIndex","argsLength","onlyChild","child","append","beforeNode","merge","element","createCache","cachedInputs","cachedOutcome","invalidate","inputs","calculation","createMapping","getSourceKey","createResult","updateResult","results","newSources","newKeys","oldTargets","source","sourceKey","searchIndex","createProjector","projector","propertyName","eventHandler","scheduleRender","scheduled","renderCompleted","stopped","projections","renderFunctions","doRender","requestAnimationFrame","stop","cancelAnimationFrame","resume","renderMaquetteFunction","replace","detach","splice","3","Benchmark","running","impl","tests","reportCallback","enableTests","_runButton","getElementById","_iterationsElement","_reportElement","body","self","preventDefault","iterations","parseInt","run","ready","Executor","v","disabled","samples","JSON","stringify","./executor","4","nodes","testInnerHtml","testName","innerHTML","console","log","cb","iterCb","_currentTest","_currentIter","_renderSamples","_updateSamples","_result","_tasksCount","_iter","iter","finished","progress","iterataions","test","renderTime","updateTime","window","performance","now","name","setTimeout","5","initFromScript","scriptUrl","src","onload","generateBenchmarkData","units","head","initFromParentWindow","parent","version","postMessage","init","qs","p","decodeURIComponent","location","search","substr","opener","testsUrl","nowOffset","Date","timing","navigationStart","./benchmark"],"mappings":"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","file":"main.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nvar benchmark = require('vdom-benchmark-base');\nvar maquette = require('maquette');\n\nvar h = maquette.h;\n\nvar NAME = 'maquette';\nvar VERSION = '2.3.2';\n\nfunction convertToVnode(node) {\n  if (node.children) {\n    return h(\"div\", {key:node.key}, node.children.map(convertToVnode));\n  } else {\n//    return { vnodeSelector: \"span\", properties: { key: node.key }, children: [{ vnodeSelector: \"\", text: node.key, domNode: null }], domNode: null };\n    return h(\"span\", {key:node.key}, [node.key]);\n  }\n}\n\nfunction BenchmarkImpl(container, a, b) {\n  this.container = container;\n  this.a = a;\n  this.b = b;\n  this.projection = null;\n}\n\nBenchmarkImpl.prototype.setUp = function() {\n};\n\nBenchmarkImpl.prototype.tearDown = function() {\n  this.projection.update(h(\"div.container\", []));\n};\n\nBenchmarkImpl.prototype.render = function() {\n  this.projection = maquette.dom.create(h(\"div.container\", this.a.map(convertToVnode)));\n  this.container.appendChild(this.projection.domNode);\n};\n\nBenchmarkImpl.prototype.update = function() {\n  this.projection.update(h(\"div.container\", this.b.map(convertToVnode)));\n};\n\ndocument.addEventListener('DOMContentLoaded', function(e) {\n  benchmark(NAME, VERSION, BenchmarkImpl);\n}, false);\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar benchmark = require('vdom-benchmark-base');\nvar maquette = require('maquette');\n\nvar h = maquette.h;\n\nvar NAME = 'maquette';\nvar VERSION = '2.3.2';\n\nfunction convertToVnode(node) {\n  if (node.children) {\n    return h(\"div\", {key:node.key}, node.children.map(convertToVnode));\n  } else {\n//    return { vnodeSelector: \"span\", properties: { key: node.key }, children: [{ vnodeSelector: \"\", text: node.key, domNode: null }], domNode: null };\n    return h(\"span\", {key:node.key}, [node.key]);\n  }\n}\n\nfunction BenchmarkImpl(container, a, b) {\n  this.container = container;\n  this.a = a;\n  this.b = b;\n  this.projection = null;\n}\n\nBenchmarkImpl.prototype.setUp = function() {\n};\n\nBenchmarkImpl.prototype.tearDown = function() {\n  this.projection.update(h(\"div.container\", []));\n};\n\nBenchmarkImpl.prototype.render = function() {\n  this.projection = maquette.dom.create(h(\"div.container\", this.a.map(convertToVnode)));\n  this.container.appendChild(this.projection.domNode);\n};\n\nBenchmarkImpl.prototype.update = function() {\n  this.projection.update(h(\"div.container\", this.b.map(convertToVnode)));\n};\n\ndocument.addEventListener('DOMContentLoaded', function(e) {\n  benchmark(NAME, VERSION, BenchmarkImpl);\n}, false);\n\n},{\"maquette\":2,\"vdom-benchmark-base\":5}],2:[function(require,module,exports){\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['exports'], factory);\n    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {\n        // CommonJS\n        factory(exports);\n    } else {\n        // Browser globals\n        factory(root.maquette = {});\n    }\n}(this, function (exports) {\n    ;\n    ;\n    ;\n    ;\n    var NAMESPACE_W3 = 'http://www.w3.org/';\n    var NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';\n    var NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';\n    // Utilities\n    var emptyArray = [];\n    var extend = function (base, overrides) {\n        var result = {};\n        Object.keys(base).forEach(function (key) {\n            result[key] = base[key];\n        });\n        if (overrides) {\n            Object.keys(overrides).forEach(function (key) {\n                result[key] = overrides[key];\n            });\n        }\n        return result;\n    };\n    // Hyperscript helper functions\n    var same = function (vnode1, vnode2) {\n        if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\n            return false;\n        }\n        if (vnode1.properties && vnode2.properties) {\n            if (vnode1.properties.key !== vnode2.properties.key) {\n                return false;\n            }\n            return vnode1.properties.bind === vnode2.properties.bind;\n        }\n        return !vnode1.properties && !vnode2.properties;\n    };\n    var toTextVNode = function (data) {\n        return {\n            vnodeSelector: '',\n            properties: undefined,\n            children: undefined,\n            text: data.toString(),\n            domNode: null\n        };\n    };\n    var appendChildren = function (parentSelector, insertions, main) {\n        for (var i = 0; i < insertions.length; i++) {\n            var item = insertions[i];\n            if (Array.isArray(item)) {\n                appendChildren(parentSelector, item, main);\n            } else {\n                if (item !== null && item !== undefined) {\n                    if (!item.hasOwnProperty('vnodeSelector')) {\n                        item = toTextVNode(item);\n                    }\n                    main.push(item);\n                }\n            }\n        }\n    };\n    // Render helper functions\n    var missingTransition = function () {\n        throw new Error('Provide a transitions object to the projectionOptions to do animations');\n    };\n    var DEFAULT_PROJECTION_OPTIONS = {\n        namespace: undefined,\n        eventHandlerInterceptor: undefined,\n        styleApplyer: function (domNode, styleName, value) {\n            // Provides a hook to add vendor prefixes for browsers that still need it.\n            domNode.style[styleName] = value;\n        },\n        transitions: {\n            enter: missingTransition,\n            exit: missingTransition\n        }\n    };\n    var applyDefaultProjectionOptions = function (projectorOptions) {\n        return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);\n    };\n    var checkStyleValue = function (styleValue) {\n        if (typeof styleValue !== 'string') {\n            throw new Error('Style values must be strings');\n        }\n    };\n    var setProperties = function (domNode, properties, projectionOptions) {\n        if (!properties) {\n            return;\n        }\n        var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\n        var propNames = Object.keys(properties);\n        var propCount = propNames.length;\n        for (var i = 0; i < propCount; i++) {\n            var propName = propNames[i];\n            /* tslint:disable:no-var-keyword: edge case */\n            var propValue = properties[propName];\n            /* tslint:enable:no-var-keyword */\n            if (propName === 'className') {\n                throw new Error('Property \"className\" is not supported, use \"class\".');\n            } else if (propName === 'class') {\n                propValue.split(/\\s+/).forEach(function (token) {\n                    return domNode.classList.add(token);\n                });\n            } else if (propName === 'classes') {\n                // object with string keys and boolean values\n                var classNames = Object.keys(propValue);\n                var classNameCount = classNames.length;\n                for (var j = 0; j < classNameCount; j++) {\n                    var className = classNames[j];\n                    if (propValue[className]) {\n                        domNode.classList.add(className);\n                    }\n                }\n            } else if (propName === 'styles') {\n                // object with string keys and string (!) values\n                var styleNames = Object.keys(propValue);\n                var styleCount = styleNames.length;\n                for (var j = 0; j < styleCount; j++) {\n                    var styleName = styleNames[j];\n                    var styleValue = propValue[styleName];\n                    if (styleValue) {\n                        checkStyleValue(styleValue);\n                        projectionOptions.styleApplyer(domNode, styleName, styleValue);\n                    }\n                }\n            } else if (propName === 'key') {\n                continue;\n            } else if (propValue === null || propValue === undefined) {\n                continue;\n            } else {\n                var type = typeof propValue;\n                if (type === 'function') {\n                    if (propName.lastIndexOf('on', 0) === 0) {\n                        if (eventHandlerInterceptor) {\n                            propValue = eventHandlerInterceptor(propName, propValue, domNode, properties);    // intercept eventhandlers\n                        }\n                        if (propName === 'oninput') {\n                            (function () {\n                                // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput\n                                var oldPropValue = propValue;\n                                propValue = function (evt) {\n                                    evt.target['oninput-value'] = evt.target.value;\n                                    // may be HTMLTextAreaElement as well\n                                    oldPropValue.apply(this, [evt]);\n                                };\n                            }());\n                        }\n                        domNode[propName] = propValue;\n                    }\n                } else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {\n                    if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n                        domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n                    } else {\n                        domNode.setAttribute(propName, propValue);\n                    }\n                } else {\n                    domNode[propName] = propValue;\n                }\n            }\n        }\n    };\n    var updateProperties = function (domNode, previousProperties, properties, projectionOptions) {\n        if (!properties) {\n            return;\n        }\n        var propertiesUpdated = false;\n        var propNames = Object.keys(properties);\n        var propCount = propNames.length;\n        for (var i = 0; i < propCount; i++) {\n            var propName = propNames[i];\n            // assuming that properties will be nullified instead of missing is by design\n            var propValue = properties[propName];\n            var previousValue = previousProperties[propName];\n            if (propName === 'class') {\n                if (previousValue !== propValue) {\n                    throw new Error('\"class\" property may not be updated. Use the \"classes\" property for conditional css classes.');\n                }\n            } else if (propName === 'classes') {\n                var classList = domNode.classList;\n                var classNames = Object.keys(propValue);\n                var classNameCount = classNames.length;\n                for (var j = 0; j < classNameCount; j++) {\n                    var className = classNames[j];\n                    var on = !!propValue[className];\n                    var previousOn = !!previousValue[className];\n                    if (on === previousOn) {\n                        continue;\n                    }\n                    propertiesUpdated = true;\n                    if (on) {\n                        classList.add(className);\n                    } else {\n                        classList.remove(className);\n                    }\n                }\n            } else if (propName === 'styles') {\n                var styleNames = Object.keys(propValue);\n                var styleCount = styleNames.length;\n                for (var j = 0; j < styleCount; j++) {\n                    var styleName = styleNames[j];\n                    var newStyleValue = propValue[styleName];\n                    var oldStyleValue = previousValue[styleName];\n                    if (newStyleValue === oldStyleValue) {\n                        continue;\n                    }\n                    propertiesUpdated = true;\n                    if (newStyleValue) {\n                        checkStyleValue(newStyleValue);\n                        projectionOptions.styleApplyer(domNode, styleName, newStyleValue);\n                    } else {\n                        projectionOptions.styleApplyer(domNode, styleName, '');\n                    }\n                }\n            } else {\n                if (!propValue && typeof previousValue === 'string') {\n                    propValue = '';\n                }\n                if (propName === 'value') {\n                    if (domNode[propName] !== propValue && domNode['oninput-value'] !== propValue) {\n                        domNode[propName] = propValue;\n                        // Reset the value, even if the virtual DOM did not change\n                        domNode['oninput-value'] = undefined;\n                    }\n                    // else do not update the domNode, otherwise the cursor position would be changed\n                    if (propValue !== previousValue) {\n                        propertiesUpdated = true;\n                    }\n                } else if (propValue !== previousValue) {\n                    var type = typeof propValue;\n                    if (type === 'function') {\n                        throw new Error('Functions may not be updated on subsequent renders (property: ' + propName + '). Hint: declare event handler functions outside the render() function.');\n                    }\n                    if (type === 'string' && propName !== 'innerHTML') {\n                        if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n                            domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n                        } else {\n                            domNode.setAttribute(propName, propValue);\n                        }\n                    } else {\n                        if (domNode[propName] !== propValue) {\n                            domNode[propName] = propValue;\n                        }\n                    }\n                    propertiesUpdated = true;\n                }\n            }\n        }\n        return propertiesUpdated;\n    };\n    var findIndexOfChild = function (children, sameAs, start) {\n        if (sameAs.vnodeSelector !== '') {\n            // Never scan for text-nodes\n            for (var i = start; i < children.length; i++) {\n                if (same(children[i], sameAs)) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n    var nodeAdded = function (vNode, transitions) {\n        if (vNode.properties) {\n            var enterAnimation = vNode.properties.enterAnimation;\n            if (enterAnimation) {\n                if (typeof enterAnimation === 'function') {\n                    enterAnimation(vNode.domNode, vNode.properties);\n                } else {\n                    transitions.enter(vNode.domNode, vNode.properties, enterAnimation);\n                }\n            }\n        }\n    };\n    var nodeToRemove = function (vNode, transitions) {\n        var domNode = vNode.domNode;\n        if (vNode.properties) {\n            var exitAnimation = vNode.properties.exitAnimation;\n            if (exitAnimation) {\n                domNode.style.pointerEvents = 'none';\n                var removeDomNode = function () {\n                    if (domNode.parentNode) {\n                        domNode.parentNode.removeChild(domNode);\n                    }\n                };\n                if (typeof exitAnimation === 'function') {\n                    exitAnimation(domNode, removeDomNode, vNode.properties);\n                    return;\n                } else {\n                    transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);\n                    return;\n                }\n            }\n        }\n        if (domNode.parentNode) {\n            domNode.parentNode.removeChild(domNode);\n        }\n    };\n    var checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {\n        var childNode = childNodes[indexToCheck];\n        if (childNode.vnodeSelector === '') {\n            return;    // Text nodes need not be distinguishable\n        }\n        var properties = childNode.properties;\n        var key = properties ? properties.key === undefined ? properties.bind : properties.key : undefined;\n        if (!key) {\n            for (var i = 0; i < childNodes.length; i++) {\n                if (i !== indexToCheck) {\n                    var node = childNodes[i];\n                    if (same(node, childNode)) {\n                        if (operation === 'added') {\n                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'added, but there is now more than one. You must add unique key properties to make them distinguishable.');\n                        } else {\n                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'removed, but there were more than one. You must add unique key properties to make them distinguishable.');\n                        }\n                    }\n                }\n            }\n        }\n    };\n    var createDom;\n    var updateDom;\n    var updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {\n        if (oldChildren === newChildren) {\n            return false;\n        }\n        oldChildren = oldChildren || emptyArray;\n        newChildren = newChildren || emptyArray;\n        var oldChildrenLength = oldChildren.length;\n        var newChildrenLength = newChildren.length;\n        var transitions = projectionOptions.transitions;\n        var oldIndex = 0;\n        var newIndex = 0;\n        var i;\n        var textUpdated = false;\n        while (newIndex < newChildrenLength) {\n            var oldChild = oldIndex < oldChildrenLength ? oldChildren[oldIndex] : undefined;\n            var newChild = newChildren[newIndex];\n            if (oldChild !== undefined && same(oldChild, newChild)) {\n                textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\n                oldIndex++;\n            } else {\n                var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\n                if (findOldIndex >= 0) {\n                    // Remove preceding missing children\n                    for (i = oldIndex; i < findOldIndex; i++) {\n                        nodeToRemove(oldChildren[i], transitions);\n                        checkDistinguishable(oldChildren, i, vnode, 'removed');\n                    }\n                    textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\n                    oldIndex = findOldIndex + 1;\n                } else {\n                    // New child\n                    createDom(newChild, domNode, oldIndex < oldChildrenLength ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\n                    nodeAdded(newChild, transitions);\n                    checkDistinguishable(newChildren, newIndex, vnode, 'added');\n                }\n            }\n            newIndex++;\n        }\n        if (oldChildrenLength > oldIndex) {\n            // Remove child fragments\n            for (i = oldIndex; i < oldChildrenLength; i++) {\n                nodeToRemove(oldChildren[i], transitions);\n                checkDistinguishable(oldChildren, i, vnode, 'removed');\n            }\n        }\n        return textUpdated;\n    };\n    var addChildren = function (domNode, children, projectionOptions) {\n        if (!children) {\n            return;\n        }\n        for (var i = 0; i < children.length; i++) {\n            createDom(children[i], domNode, undefined, projectionOptions);\n        }\n    };\n    var initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {\n        addChildren(domNode, vnode.children, projectionOptions);\n        // children before properties, needed for value property of <select>.\n        if (vnode.text) {\n            domNode.textContent = vnode.text;\n        }\n        setProperties(domNode, vnode.properties, projectionOptions);\n        if (vnode.properties && vnode.properties.afterCreate) {\n            vnode.properties.afterCreate(domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children);\n        }\n    };\n    createDom = function (vnode, parentNode, insertBefore, projectionOptions) {\n        var domNode, i, c, start = 0, type, found;\n        var vnodeSelector = vnode.vnodeSelector;\n        if (vnodeSelector === '') {\n            domNode = vnode.domNode = document.createTextNode(vnode.text);\n            if (insertBefore !== undefined) {\n                parentNode.insertBefore(domNode, insertBefore);\n            } else {\n                parentNode.appendChild(domNode);\n            }\n        } else {\n            for (i = 0; i <= vnodeSelector.length; ++i) {\n                c = vnodeSelector.charAt(i);\n                if (i === vnodeSelector.length || c === '.' || c === '#') {\n                    type = vnodeSelector.charAt(start - 1);\n                    found = vnodeSelector.slice(start, i);\n                    if (type === '.') {\n                        domNode.classList.add(found);\n                    } else if (type === '#') {\n                        domNode.id = found;\n                    } else {\n                        if (found === 'svg') {\n                            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n                        }\n                        if (projectionOptions.namespace !== undefined) {\n                            domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);\n                        } else {\n                            domNode = vnode.domNode = document.createElement(found);\n                        }\n                        if (insertBefore !== undefined) {\n                            parentNode.insertBefore(domNode, insertBefore);\n                        } else {\n                            parentNode.appendChild(domNode);\n                        }\n                    }\n                    start = i + 1;\n                }\n            }\n            initPropertiesAndChildren(domNode, vnode, projectionOptions);\n        }\n    };\n    updateDom = function (previous, vnode, projectionOptions) {\n        var domNode = previous.domNode;\n        var textUpdated = false;\n        if (previous === vnode) {\n            return false;    // By contract, VNode objects may not be modified anymore after passing them to maquette\n        }\n        var updated = false;\n        if (vnode.vnodeSelector === '') {\n            if (vnode.text !== previous.text) {\n                var newVNode = document.createTextNode(vnode.text);\n                domNode.parentNode.replaceChild(newVNode, domNode);\n                vnode.domNode = newVNode;\n                textUpdated = true;\n                return textUpdated;\n            }\n        } else {\n            if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) {\n                projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n            }\n            if (previous.text !== vnode.text) {\n                updated = true;\n                if (vnode.text === undefined) {\n                    domNode.removeChild(domNode.firstChild);    // the only textnode presumably\n                } else {\n                    domNode.textContent = vnode.text;\n                }\n            }\n            updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\n            updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\n            if (vnode.properties && vnode.properties.afterUpdate) {\n                vnode.properties.afterUpdate(domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children);\n            }\n        }\n        if (updated && vnode.properties && vnode.properties.updateAnimation) {\n            vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);\n        }\n        vnode.domNode = previous.domNode;\n        return textUpdated;\n    };\n    var createProjection = function (vnode, projectionOptions) {\n        return {\n            update: function (updatedVnode) {\n                if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\n                    throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');\n                }\n                updateDom(vnode, updatedVnode, projectionOptions);\n                vnode = updatedVnode;\n            },\n            domNode: vnode.domNode\n        };\n    };\n    ;\n    // The other two parameters are not added here, because the Typescript compiler creates surrogate code for desctructuring 'children'.\n    exports.h = function (selector) {\n        var properties = arguments[1];\n        if (typeof selector !== 'string') {\n            throw new Error();\n        }\n        var childIndex = 1;\n        if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {\n            childIndex = 2;\n        } else {\n            // Optional properties argument was omitted\n            properties = undefined;\n        }\n        var text = undefined;\n        var children = undefined;\n        var argsLength = arguments.length;\n        // Recognize a common special case where there is only a single text node\n        if (argsLength === childIndex + 1) {\n            var onlyChild = arguments[childIndex];\n            if (typeof onlyChild === 'string') {\n                text = onlyChild;\n            } else if (onlyChild !== undefined && onlyChild !== null && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {\n                text = onlyChild[0];\n            }\n        }\n        if (text === undefined) {\n            children = [];\n            for (; childIndex < arguments.length; childIndex++) {\n                var child = arguments[childIndex];\n                if (child === null || child === undefined) {\n                    continue;\n                } else if (Array.isArray(child)) {\n                    appendChildren(selector, child, children);\n                } else if (child.hasOwnProperty('vnodeSelector')) {\n                    children.push(child);\n                } else {\n                    children.push(toTextVNode(child));\n                }\n            }\n        }\n        return {\n            vnodeSelector: selector,\n            properties: properties,\n            children: children,\n            text: text === '' ? undefined : text,\n            domNode: null\n        };\n    };\n    /**\n * Contains simple low-level utility functions to manipulate the real DOM.\n */\n    exports.dom = {\n        /**\n     * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in\n     * its [[Projection.domNode|domNode]] property.\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection.\n     * @returns The [[Projection]] which also contains the DOM Node that was created.\n     */\n        create: function (vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, document.createElement('div'), undefined, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Appends a new childnode to the DOM which is generated from a [[VNode]].\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param parentNode - The parent node for the new childNode.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the [[Projection]].\n     * @returns The [[Projection]] that was created.\n     */\n        append: function (parentNode, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, parentNode, undefined, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Inserts a new DOM node which is generated from a [[VNode]].\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param beforeNode - The node that the DOM Node is inserted before.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.\n     * NOTE: [[VNode]] objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n     * @returns The [[Projection]] that was created.\n     */\n        insertBefore: function (beforeNode, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.\n     * This means that the virtual DOM and the real DOM will have one overlapping element.\n     * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param domNode - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects\n     * may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n     * @returns The [[Projection]] that was created.\n     */\n        merge: function (element, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            vnode.domNode = element;\n            initPropertiesAndChildren(element, vnode, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        }\n    };\n    /**\n * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.\n * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.\n * For more information, see [[CalculationCache]].\n *\n * @param <Result> The type of the value that is cached.\n */\n    exports.createCache = function () {\n        var cachedInputs = undefined;\n        var cachedOutcome = undefined;\n        var result = {\n            invalidate: function () {\n                cachedOutcome = undefined;\n                cachedInputs = undefined;\n            },\n            result: function (inputs, calculation) {\n                if (cachedInputs) {\n                    for (var i = 0; i < inputs.length; i++) {\n                        if (cachedInputs[i] !== inputs[i]) {\n                            cachedOutcome = undefined;\n                        }\n                    }\n                }\n                if (!cachedOutcome) {\n                    cachedOutcome = calculation();\n                    cachedInputs = inputs;\n                }\n                return cachedOutcome;\n            }\n        };\n        return result;\n    };\n    /**\n * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\n * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.\n *\n * @param <Source>       The type of source items. A database-record for instance.\n * @param <Target>       The type of target items. A [[Component]] for instance.\n * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.\n * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical\n *                       to the `callback` argument in `Array.map(callback)`.\n * @param updateResult   `function(source, target, index)` that updates a result to an updated source.\n */\n    exports.createMapping = function (getSourceKey, createResult, updateResult) {\n        var keys = [];\n        var results = [];\n        return {\n            results: results,\n            map: function (newSources) {\n                var newKeys = newSources.map(getSourceKey);\n                var oldTargets = results.slice();\n                var oldIndex = 0;\n                for (var i = 0; i < newSources.length; i++) {\n                    var source = newSources[i];\n                    var sourceKey = newKeys[i];\n                    if (sourceKey === keys[oldIndex]) {\n                        results[i] = oldTargets[oldIndex];\n                        updateResult(source, oldTargets[oldIndex], i);\n                        oldIndex++;\n                    } else {\n                        var found = false;\n                        for (var j = 1; j < keys.length + 1; j++) {\n                            var searchIndex = (oldIndex + j) % keys.length;\n                            if (keys[searchIndex] === sourceKey) {\n                                results[i] = oldTargets[searchIndex];\n                                updateResult(newSources[i], oldTargets[searchIndex], i);\n                                oldIndex = searchIndex + 1;\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            results[i] = createResult(source, i);\n                        }\n                    }\n                }\n                results.length = newSources.length;\n                keys = newKeys;\n            }\n        };\n    };\n    /**\n * Creates a [[Projector]] instance using the provided projectionOptions.\n *\n * For more information, see [[Projector]].\n *\n * @param projectionOptions   Options that influence how the DOM is rendered and updated.\n */\n    exports.createProjector = function (projectorOptions) {\n        var projector;\n        var projectionOptions = applyDefaultProjectionOptions(projectorOptions);\n        projectionOptions.eventHandlerInterceptor = function (propertyName, eventHandler, domNode, properties) {\n            return function () {\n                // intercept function calls (event handlers) to do a render afterwards.\n                projector.scheduleRender();\n                return eventHandler.apply(properties.bind || this, arguments);\n            };\n        };\n        var renderCompleted = true;\n        var scheduled;\n        var stopped = false;\n        var projections = [];\n        var renderFunctions = [];\n        // matches the projections array\n        var doRender = function () {\n            scheduled = undefined;\n            if (!renderCompleted) {\n                return;    // The last render threw an error, it should be logged in the browser console.\n            }\n            renderCompleted = false;\n            for (var i = 0; i < projections.length; i++) {\n                var updatedVnode = renderFunctions[i]();\n                projections[i].update(updatedVnode);\n            }\n            renderCompleted = true;\n        };\n        projector = {\n            scheduleRender: function () {\n                if (!scheduled && !stopped) {\n                    scheduled = requestAnimationFrame(doRender);\n                }\n            },\n            stop: function () {\n                if (scheduled) {\n                    cancelAnimationFrame(scheduled);\n                    scheduled = undefined;\n                }\n                stopped = true;\n            },\n            resume: function () {\n                stopped = false;\n                renderCompleted = true;\n                projector.scheduleRender();\n            },\n            append: function (parentNode, renderMaquetteFunction) {\n                projections.push(exports.dom.append(parentNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            insertBefore: function (beforeNode, renderMaquetteFunction) {\n                projections.push(exports.dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            merge: function (domNode, renderMaquetteFunction) {\n                projections.push(exports.dom.merge(domNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            replace: function (domNode, renderMaquetteFunction) {\n                var vnode = renderMaquetteFunction();\n                createDom(vnode, domNode.parentNode, domNode, projectionOptions);\n                domNode.parentNode.removeChild(domNode);\n                projections.push(createProjection(vnode, projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            detach: function (renderMaquetteFunction) {\n                for (var i = 0; i < renderFunctions.length; i++) {\n                    if (renderFunctions[i] === renderMaquetteFunction) {\n                        renderFunctions.splice(i, 1);\n                        return projections.splice(i, 1)[0];\n                    }\n                }\n                throw new Error('renderMaquetteFunction was not found');\n            }\n        };\n        return projector;\n    };\n}));\n//# sourceMappingURL=maquette.js.map\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\nvar Executor = require('./executor');\n\nfunction Benchmark() {\n  this.running = false;\n  this.impl = null;\n  this.tests = null;\n  this.reportCallback = null;\n  this.enableTests = false;\n\n  this.container = document.createElement('div');\n\n  this._runButton = document.getElementById('RunButton');\n  this._iterationsElement = document.getElementById('Iterations');\n  this._reportElement = document.createElement('pre');\n\n  document.body.appendChild(this.container);\n  document.body.appendChild(this._reportElement);\n\n  var self = this;\n\n  this._runButton.addEventListener('click', function(e) {\n    e.preventDefault();\n\n    if (!self.running) {\n      var iterations = parseInt(self._iterationsElement.value);\n      if (iterations <= 0) {\n        iterations = 10;\n      }\n\n      self.run(iterations);\n    }\n  }, false);\n\n  this.ready(true);\n}\n\nBenchmark.prototype.ready = function(v) {\n  if (v) {\n    this._runButton.disabled = '';\n  } else {\n    this._runButton.disabled = 'true';\n  }\n};\n\nBenchmark.prototype.run = function(iterations) {\n  var self = this;\n  this.running = true;\n  this.ready(false);\n\n  new Executor(self.impl, self.container, self.tests, 1, function() { // warmup\n    new Executor(self.impl, self.container, self.tests, iterations, function(samples) {\n      self._reportElement.textContent = JSON.stringify(samples, null, ' ');\n      self.running = false;\n      self.ready(true);\n      if (self.reportCallback != null) {\n        self.reportCallback(samples);\n      }\n    }, undefined, false).start();\n  }, undefined, this.enableTests).start();\n};\n\nmodule.exports = Benchmark;\n\n},{\"./executor\":4}],4:[function(require,module,exports){\n'use strict';\n\nfunction render(nodes) {\n  var children = [];\n  var j;\n  var c;\n  var i;\n  var e;\n  var n;\n\n  for (i = 0; i < nodes.length; i++) {\n    n = nodes[i];\n    if (n.children !== null) {\n      e = document.createElement('div');\n      c = render(n.children);\n      for (j = 0; j < c.length; j++) {\n        e.appendChild(c[j]);\n      }\n      children.push(e);\n    } else {\n      e = document.createElement('span');\n      e.textContent = n.key.toString();\n      children.push(e);\n    }\n  }\n\n  return children;\n}\n\nfunction testInnerHtml(testName, nodes, container) {\n  var c = document.createElement('div');\n  var e = document.createElement('div');\n  var children = render(nodes);\n  for (var i = 0; i < children.length; i++) {\n    e.appendChild(children[i]);\n  }\n  c.appendChild(e);\n  if (c.innerHTML !== container.innerHTML) {\n    console.log('error in test: ' + testName);\n    console.log('container.innerHTML:');\n    console.log(container.innerHTML);\n    console.log('should be:');\n    console.log(c.innerHTML);\n  }\n}\n\n\nfunction Executor(impl, container, tests, iterations, cb, iterCb, enableTests) {\n  if (iterCb === void 0) iterCb = null;\n\n  this.impl = impl;\n  this.container = container;\n  this.tests = tests;\n  this.iterations = iterations;\n  this.cb = cb;\n  this.iterCb = iterCb;\n  this.enableTests = enableTests;\n\n  this._currentTest = 0;\n  this._currentIter = 0;\n  this._renderSamples = [];\n  this._updateSamples = [];\n  this._result = [];\n\n  this._tasksCount = tests.length * iterations;\n\n  this._iter = this.iter.bind(this);\n}\n\nExecutor.prototype.start = function() {\n  this._iter();\n};\n\nExecutor.prototype.finished = function() {\n  this.cb(this._result);\n};\n\nExecutor.prototype.progress = function() {\n  if (this._currentTest === 0 && this._currentIter === 0) {\n    return 0;\n  }\n\n  var tests = this.tests;\n  return (this._currentTest * tests.length + this._currentIter) / (tests.length * this.iterataions);\n};\n\nExecutor.prototype.iter = function() {\n  if (this.iterCb != null) {\n    this.iterCb(this);\n  }\n\n  var tests = this.tests;\n\n  if (this._currentTest < tests.length) {\n    var test = tests[this._currentTest];\n\n    if (this._currentIter < this.iterations) {\n      var e, t;\n      var renderTime, updateTime;\n\n      e = new this.impl(this.container, test.data.a, test.data.b);\n      e.setUp();\n\n      t = window.performance.now();\n      e.render();\n      renderTime = window.performance.now() - t;\n\n      if (this.enableTests) {\n        testInnerHtml(test.name + 'render()', test.data.a, this.container);\n      }\n\n      t = window.performance.now();\n      e.update();\n      updateTime = window.performance.now() - t;\n\n      if (this.enableTests) {\n        testInnerHtml(test.name + 'update()', test.data.b, this.container);\n      }\n\n      e.tearDown();\n\n      this._renderSamples.push(renderTime);\n      this._updateSamples.push(updateTime);\n\n      this._currentIter++;\n    } else {\n      this._result.push({\n        name: test.name + ' ' + 'render()',\n        data: this._renderSamples.slice(0)\n      });\n\n      this._result.push({\n        name: test.name + ' ' + 'update()',\n        data: this._updateSamples.slice(0)\n      });\n\n      this._currentTest++;\n\n      this._currentIter = 0;\n      this._renderSamples = [];\n      this._updateSamples = [];\n    }\n\n    setTimeout(this._iter, 0);\n  } else {\n    this.finished();\n  }\n};\n\nmodule.exports = Executor;\n\n},{}],5:[function(require,module,exports){\n'use strict';\n\nvar Benchmark = require('./benchmark');\nvar benchmark = new Benchmark();\n\nfunction initFromScript(scriptUrl, impl) {\n  var e = document.createElement('script');\n  e.src = scriptUrl;\n\n  e.onload = function() {\n    benchmark.tests = window.generateBenchmarkData().units;\n    benchmark.ready(true);\n  };\n\n  document.head.appendChild(e);\n}\n\nfunction initFromParentWindow(parent, name, version, id) {\n  window.addEventListener('message', function(e) {\n    var data = e.data;\n    var type = data.type;\n\n    if (type === 'tests') {\n      benchmark.tests = data.data;\n      benchmark.reportCallback = function(samples) {\n        parent.postMessage({\n          type: 'report',\n          data: {\n            name: name,\n            version: version,\n            samples: samples\n          },\n          id: id\n        }, '*');\n      };\n      benchmark.ready(true);\n\n      parent.postMessage({\n        type: 'ready',\n        data: null,\n        id: id\n      }, '*');\n    } else if (type === 'run') {\n      benchmark.run(data.data.iterations);\n    }\n  }, false);\n\n  parent.postMessage({\n    type: 'init',\n    data: null,\n    id: id\n  }, '*');\n}\n\nfunction init(name, version, impl) {\n  // Parse Query String.\n  var qs = (function(a) {\n    if (a == \"\") return {};\n    var b = {};\n    for (var i = 0; i < a.length; ++i) {\n      var p=a[i].split('=', 2);\n      if (p.length == 1) {\n        b[p[0]] = \"\";\n      } else {\n        b[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, \" \"));\n      }\n    }\n    return b;\n  })(window.location.search.substr(1).split('&'));\n\n  if (qs['name'] !== void 0) {\n    name = qs['name'];\n  }\n\n  if (qs['version'] !== void 0) {\n    version = qs['version'];\n  }\n\n  var type = qs['type'];\n\n  if (qs['test'] !== void 0) {\n    benchmark.enableTests = true;\n    console.log('tests enabled');\n  }\n\n  var id;\n  if (type === 'iframe') {\n    id = qs['id'];\n    if (id === void 0) id = null;\n    initFromParentWindow(window.parent, name, version, id);\n  } else if (type === 'window') {\n    if (window.opener != null) {\n      id = qs['id'];\n      if (id === void 0) id = null;\n      initFromParentWindow(window.opener, name, version, id);\n    } else {\n      console.log('Failed to initialize: opener window is NULL');\n    }\n  } else {\n    var testsUrl = qs['data']; // url to the script generating test data\n    if (testsUrl !== void 0) {\n      initFromScript(testsUrl);\n    } else {\n      console.log('Failed to initialize: cannot load tests data');\n    }\n  }\n\n  benchmark.impl = impl;\n}\n\n// performance.now() polyfill\n// https://gist.github.com/paulirish/5438650\n// prepare base perf object\nif (typeof window.performance === 'undefined') {\n  window.performance = {};\n}\nif (!window.performance.now){\n  var nowOffset = Date.now();\n  if (performance.timing && performance.timing.navigationStart) {\n    nowOffset = performance.timing.navigationStart;\n  }\n  window.performance.now = function now(){\n    return Date.now() - nowOffset;\n  };\n}\n\nmodule.exports = init;\n\n},{\"./benchmark\":3}]},{},[1])\n\n","(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['exports'], factory);\n    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {\n        // CommonJS\n        factory(exports);\n    } else {\n        // Browser globals\n        factory(root.maquette = {});\n    }\n}(this, function (exports) {\n    ;\n    ;\n    ;\n    ;\n    var NAMESPACE_W3 = 'http://www.w3.org/';\n    var NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';\n    var NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';\n    // Utilities\n    var emptyArray = [];\n    var extend = function (base, overrides) {\n        var result = {};\n        Object.keys(base).forEach(function (key) {\n            result[key] = base[key];\n        });\n        if (overrides) {\n            Object.keys(overrides).forEach(function (key) {\n                result[key] = overrides[key];\n            });\n        }\n        return result;\n    };\n    // Hyperscript helper functions\n    var same = function (vnode1, vnode2) {\n        if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\n            return false;\n        }\n        if (vnode1.properties && vnode2.properties) {\n            if (vnode1.properties.key !== vnode2.properties.key) {\n                return false;\n            }\n            return vnode1.properties.bind === vnode2.properties.bind;\n        }\n        return !vnode1.properties && !vnode2.properties;\n    };\n    var toTextVNode = function (data) {\n        return {\n            vnodeSelector: '',\n            properties: undefined,\n            children: undefined,\n            text: data.toString(),\n            domNode: null\n        };\n    };\n    var appendChildren = function (parentSelector, insertions, main) {\n        for (var i = 0; i < insertions.length; i++) {\n            var item = insertions[i];\n            if (Array.isArray(item)) {\n                appendChildren(parentSelector, item, main);\n            } else {\n                if (item !== null && item !== undefined) {\n                    if (!item.hasOwnProperty('vnodeSelector')) {\n                        item = toTextVNode(item);\n                    }\n                    main.push(item);\n                }\n            }\n        }\n    };\n    // Render helper functions\n    var missingTransition = function () {\n        throw new Error('Provide a transitions object to the projectionOptions to do animations');\n    };\n    var DEFAULT_PROJECTION_OPTIONS = {\n        namespace: undefined,\n        eventHandlerInterceptor: undefined,\n        styleApplyer: function (domNode, styleName, value) {\n            // Provides a hook to add vendor prefixes for browsers that still need it.\n            domNode.style[styleName] = value;\n        },\n        transitions: {\n            enter: missingTransition,\n            exit: missingTransition\n        }\n    };\n    var applyDefaultProjectionOptions = function (projectorOptions) {\n        return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);\n    };\n    var checkStyleValue = function (styleValue) {\n        if (typeof styleValue !== 'string') {\n            throw new Error('Style values must be strings');\n        }\n    };\n    var setProperties = function (domNode, properties, projectionOptions) {\n        if (!properties) {\n            return;\n        }\n        var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\n        var propNames = Object.keys(properties);\n        var propCount = propNames.length;\n        for (var i = 0; i < propCount; i++) {\n            var propName = propNames[i];\n            /* tslint:disable:no-var-keyword: edge case */\n            var propValue = properties[propName];\n            /* tslint:enable:no-var-keyword */\n            if (propName === 'className') {\n                throw new Error('Property \"className\" is not supported, use \"class\".');\n            } else if (propName === 'class') {\n                propValue.split(/\\s+/).forEach(function (token) {\n                    return domNode.classList.add(token);\n                });\n            } else if (propName === 'classes') {\n                // object with string keys and boolean values\n                var classNames = Object.keys(propValue);\n                var classNameCount = classNames.length;\n                for (var j = 0; j < classNameCount; j++) {\n                    var className = classNames[j];\n                    if (propValue[className]) {\n                        domNode.classList.add(className);\n                    }\n                }\n            } else if (propName === 'styles') {\n                // object with string keys and string (!) values\n                var styleNames = Object.keys(propValue);\n                var styleCount = styleNames.length;\n                for (var j = 0; j < styleCount; j++) {\n                    var styleName = styleNames[j];\n                    var styleValue = propValue[styleName];\n                    if (styleValue) {\n                        checkStyleValue(styleValue);\n                        projectionOptions.styleApplyer(domNode, styleName, styleValue);\n                    }\n                }\n            } else if (propName === 'key') {\n                continue;\n            } else if (propValue === null || propValue === undefined) {\n                continue;\n            } else {\n                var type = typeof propValue;\n                if (type === 'function') {\n                    if (propName.lastIndexOf('on', 0) === 0) {\n                        if (eventHandlerInterceptor) {\n                            propValue = eventHandlerInterceptor(propName, propValue, domNode, properties);    // intercept eventhandlers\n                        }\n                        if (propName === 'oninput') {\n                            (function () {\n                                // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput\n                                var oldPropValue = propValue;\n                                propValue = function (evt) {\n                                    evt.target['oninput-value'] = evt.target.value;\n                                    // may be HTMLTextAreaElement as well\n                                    oldPropValue.apply(this, [evt]);\n                                };\n                            }());\n                        }\n                        domNode[propName] = propValue;\n                    }\n                } else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {\n                    if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n                        domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n                    } else {\n                        domNode.setAttribute(propName, propValue);\n                    }\n                } else {\n                    domNode[propName] = propValue;\n                }\n            }\n        }\n    };\n    var updateProperties = function (domNode, previousProperties, properties, projectionOptions) {\n        if (!properties) {\n            return;\n        }\n        var propertiesUpdated = false;\n        var propNames = Object.keys(properties);\n        var propCount = propNames.length;\n        for (var i = 0; i < propCount; i++) {\n            var propName = propNames[i];\n            // assuming that properties will be nullified instead of missing is by design\n            var propValue = properties[propName];\n            var previousValue = previousProperties[propName];\n            if (propName === 'class') {\n                if (previousValue !== propValue) {\n                    throw new Error('\"class\" property may not be updated. Use the \"classes\" property for conditional css classes.');\n                }\n            } else if (propName === 'classes') {\n                var classList = domNode.classList;\n                var classNames = Object.keys(propValue);\n                var classNameCount = classNames.length;\n                for (var j = 0; j < classNameCount; j++) {\n                    var className = classNames[j];\n                    var on = !!propValue[className];\n                    var previousOn = !!previousValue[className];\n                    if (on === previousOn) {\n                        continue;\n                    }\n                    propertiesUpdated = true;\n                    if (on) {\n                        classList.add(className);\n                    } else {\n                        classList.remove(className);\n                    }\n                }\n            } else if (propName === 'styles') {\n                var styleNames = Object.keys(propValue);\n                var styleCount = styleNames.length;\n                for (var j = 0; j < styleCount; j++) {\n                    var styleName = styleNames[j];\n                    var newStyleValue = propValue[styleName];\n                    var oldStyleValue = previousValue[styleName];\n                    if (newStyleValue === oldStyleValue) {\n                        continue;\n                    }\n                    propertiesUpdated = true;\n                    if (newStyleValue) {\n                        checkStyleValue(newStyleValue);\n                        projectionOptions.styleApplyer(domNode, styleName, newStyleValue);\n                    } else {\n                        projectionOptions.styleApplyer(domNode, styleName, '');\n                    }\n                }\n            } else {\n                if (!propValue && typeof previousValue === 'string') {\n                    propValue = '';\n                }\n                if (propName === 'value') {\n                    if (domNode[propName] !== propValue && domNode['oninput-value'] !== propValue) {\n                        domNode[propName] = propValue;\n                        // Reset the value, even if the virtual DOM did not change\n                        domNode['oninput-value'] = undefined;\n                    }\n                    // else do not update the domNode, otherwise the cursor position would be changed\n                    if (propValue !== previousValue) {\n                        propertiesUpdated = true;\n                    }\n                } else if (propValue !== previousValue) {\n                    var type = typeof propValue;\n                    if (type === 'function') {\n                        throw new Error('Functions may not be updated on subsequent renders (property: ' + propName + '). Hint: declare event handler functions outside the render() function.');\n                    }\n                    if (type === 'string' && propName !== 'innerHTML') {\n                        if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n                            domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n                        } else {\n                            domNode.setAttribute(propName, propValue);\n                        }\n                    } else {\n                        if (domNode[propName] !== propValue) {\n                            domNode[propName] = propValue;\n                        }\n                    }\n                    propertiesUpdated = true;\n                }\n            }\n        }\n        return propertiesUpdated;\n    };\n    var findIndexOfChild = function (children, sameAs, start) {\n        if (sameAs.vnodeSelector !== '') {\n            // Never scan for text-nodes\n            for (var i = start; i < children.length; i++) {\n                if (same(children[i], sameAs)) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n    var nodeAdded = function (vNode, transitions) {\n        if (vNode.properties) {\n            var enterAnimation = vNode.properties.enterAnimation;\n            if (enterAnimation) {\n                if (typeof enterAnimation === 'function') {\n                    enterAnimation(vNode.domNode, vNode.properties);\n                } else {\n                    transitions.enter(vNode.domNode, vNode.properties, enterAnimation);\n                }\n            }\n        }\n    };\n    var nodeToRemove = function (vNode, transitions) {\n        var domNode = vNode.domNode;\n        if (vNode.properties) {\n            var exitAnimation = vNode.properties.exitAnimation;\n            if (exitAnimation) {\n                domNode.style.pointerEvents = 'none';\n                var removeDomNode = function () {\n                    if (domNode.parentNode) {\n                        domNode.parentNode.removeChild(domNode);\n                    }\n                };\n                if (typeof exitAnimation === 'function') {\n                    exitAnimation(domNode, removeDomNode, vNode.properties);\n                    return;\n                } else {\n                    transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);\n                    return;\n                }\n            }\n        }\n        if (domNode.parentNode) {\n            domNode.parentNode.removeChild(domNode);\n        }\n    };\n    var checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {\n        var childNode = childNodes[indexToCheck];\n        if (childNode.vnodeSelector === '') {\n            return;    // Text nodes need not be distinguishable\n        }\n        var properties = childNode.properties;\n        var key = properties ? properties.key === undefined ? properties.bind : properties.key : undefined;\n        if (!key) {\n            for (var i = 0; i < childNodes.length; i++) {\n                if (i !== indexToCheck) {\n                    var node = childNodes[i];\n                    if (same(node, childNode)) {\n                        if (operation === 'added') {\n                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'added, but there is now more than one. You must add unique key properties to make them distinguishable.');\n                        } else {\n                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'removed, but there were more than one. You must add unique key properties to make them distinguishable.');\n                        }\n                    }\n                }\n            }\n        }\n    };\n    var createDom;\n    var updateDom;\n    var updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {\n        if (oldChildren === newChildren) {\n            return false;\n        }\n        oldChildren = oldChildren || emptyArray;\n        newChildren = newChildren || emptyArray;\n        var oldChildrenLength = oldChildren.length;\n        var newChildrenLength = newChildren.length;\n        var transitions = projectionOptions.transitions;\n        var oldIndex = 0;\n        var newIndex = 0;\n        var i;\n        var textUpdated = false;\n        while (newIndex < newChildrenLength) {\n            var oldChild = oldIndex < oldChildrenLength ? oldChildren[oldIndex] : undefined;\n            var newChild = newChildren[newIndex];\n            if (oldChild !== undefined && same(oldChild, newChild)) {\n                textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\n                oldIndex++;\n            } else {\n                var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\n                if (findOldIndex >= 0) {\n                    // Remove preceding missing children\n                    for (i = oldIndex; i < findOldIndex; i++) {\n                        nodeToRemove(oldChildren[i], transitions);\n                        checkDistinguishable(oldChildren, i, vnode, 'removed');\n                    }\n                    textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\n                    oldIndex = findOldIndex + 1;\n                } else {\n                    // New child\n                    createDom(newChild, domNode, oldIndex < oldChildrenLength ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\n                    nodeAdded(newChild, transitions);\n                    checkDistinguishable(newChildren, newIndex, vnode, 'added');\n                }\n            }\n            newIndex++;\n        }\n        if (oldChildrenLength > oldIndex) {\n            // Remove child fragments\n            for (i = oldIndex; i < oldChildrenLength; i++) {\n                nodeToRemove(oldChildren[i], transitions);\n                checkDistinguishable(oldChildren, i, vnode, 'removed');\n            }\n        }\n        return textUpdated;\n    };\n    var addChildren = function (domNode, children, projectionOptions) {\n        if (!children) {\n            return;\n        }\n        for (var i = 0; i < children.length; i++) {\n            createDom(children[i], domNode, undefined, projectionOptions);\n        }\n    };\n    var initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {\n        addChildren(domNode, vnode.children, projectionOptions);\n        // children before properties, needed for value property of <select>.\n        if (vnode.text) {\n            domNode.textContent = vnode.text;\n        }\n        setProperties(domNode, vnode.properties, projectionOptions);\n        if (vnode.properties && vnode.properties.afterCreate) {\n            vnode.properties.afterCreate(domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children);\n        }\n    };\n    createDom = function (vnode, parentNode, insertBefore, projectionOptions) {\n        var domNode, i, c, start = 0, type, found;\n        var vnodeSelector = vnode.vnodeSelector;\n        if (vnodeSelector === '') {\n            domNode = vnode.domNode = document.createTextNode(vnode.text);\n            if (insertBefore !== undefined) {\n                parentNode.insertBefore(domNode, insertBefore);\n            } else {\n                parentNode.appendChild(domNode);\n            }\n        } else {\n            for (i = 0; i <= vnodeSelector.length; ++i) {\n                c = vnodeSelector.charAt(i);\n                if (i === vnodeSelector.length || c === '.' || c === '#') {\n                    type = vnodeSelector.charAt(start - 1);\n                    found = vnodeSelector.slice(start, i);\n                    if (type === '.') {\n                        domNode.classList.add(found);\n                    } else if (type === '#') {\n                        domNode.id = found;\n                    } else {\n                        if (found === 'svg') {\n                            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n                        }\n                        if (projectionOptions.namespace !== undefined) {\n                            domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);\n                        } else {\n                            domNode = vnode.domNode = document.createElement(found);\n                        }\n                        if (insertBefore !== undefined) {\n                            parentNode.insertBefore(domNode, insertBefore);\n                        } else {\n                            parentNode.appendChild(domNode);\n                        }\n                    }\n                    start = i + 1;\n                }\n            }\n            initPropertiesAndChildren(domNode, vnode, projectionOptions);\n        }\n    };\n    updateDom = function (previous, vnode, projectionOptions) {\n        var domNode = previous.domNode;\n        var textUpdated = false;\n        if (previous === vnode) {\n            return false;    // By contract, VNode objects may not be modified anymore after passing them to maquette\n        }\n        var updated = false;\n        if (vnode.vnodeSelector === '') {\n            if (vnode.text !== previous.text) {\n                var newVNode = document.createTextNode(vnode.text);\n                domNode.parentNode.replaceChild(newVNode, domNode);\n                vnode.domNode = newVNode;\n                textUpdated = true;\n                return textUpdated;\n            }\n        } else {\n            if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) {\n                projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n            }\n            if (previous.text !== vnode.text) {\n                updated = true;\n                if (vnode.text === undefined) {\n                    domNode.removeChild(domNode.firstChild);    // the only textnode presumably\n                } else {\n                    domNode.textContent = vnode.text;\n                }\n            }\n            updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\n            updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\n            if (vnode.properties && vnode.properties.afterUpdate) {\n                vnode.properties.afterUpdate(domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children);\n            }\n        }\n        if (updated && vnode.properties && vnode.properties.updateAnimation) {\n            vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);\n        }\n        vnode.domNode = previous.domNode;\n        return textUpdated;\n    };\n    var createProjection = function (vnode, projectionOptions) {\n        return {\n            update: function (updatedVnode) {\n                if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\n                    throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');\n                }\n                updateDom(vnode, updatedVnode, projectionOptions);\n                vnode = updatedVnode;\n            },\n            domNode: vnode.domNode\n        };\n    };\n    ;\n    // The other two parameters are not added here, because the Typescript compiler creates surrogate code for desctructuring 'children'.\n    exports.h = function (selector) {\n        var properties = arguments[1];\n        if (typeof selector !== 'string') {\n            throw new Error();\n        }\n        var childIndex = 1;\n        if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {\n            childIndex = 2;\n        } else {\n            // Optional properties argument was omitted\n            properties = undefined;\n        }\n        var text = undefined;\n        var children = undefined;\n        var argsLength = arguments.length;\n        // Recognize a common special case where there is only a single text node\n        if (argsLength === childIndex + 1) {\n            var onlyChild = arguments[childIndex];\n            if (typeof onlyChild === 'string') {\n                text = onlyChild;\n            } else if (onlyChild !== undefined && onlyChild !== null && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {\n                text = onlyChild[0];\n            }\n        }\n        if (text === undefined) {\n            children = [];\n            for (; childIndex < arguments.length; childIndex++) {\n                var child = arguments[childIndex];\n                if (child === null || child === undefined) {\n                    continue;\n                } else if (Array.isArray(child)) {\n                    appendChildren(selector, child, children);\n                } else if (child.hasOwnProperty('vnodeSelector')) {\n                    children.push(child);\n                } else {\n                    children.push(toTextVNode(child));\n                }\n            }\n        }\n        return {\n            vnodeSelector: selector,\n            properties: properties,\n            children: children,\n            text: text === '' ? undefined : text,\n            domNode: null\n        };\n    };\n    /**\n * Contains simple low-level utility functions to manipulate the real DOM.\n */\n    exports.dom = {\n        /**\n     * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in\n     * its [[Projection.domNode|domNode]] property.\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection.\n     * @returns The [[Projection]] which also contains the DOM Node that was created.\n     */\n        create: function (vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, document.createElement('div'), undefined, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Appends a new childnode to the DOM which is generated from a [[VNode]].\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param parentNode - The parent node for the new childNode.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the [[Projection]].\n     * @returns The [[Projection]] that was created.\n     */\n        append: function (parentNode, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, parentNode, undefined, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Inserts a new DOM node which is generated from a [[VNode]].\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param beforeNode - The node that the DOM Node is inserted before.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.\n     * NOTE: [[VNode]] objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n     * @returns The [[Projection]] that was created.\n     */\n        insertBefore: function (beforeNode, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.\n     * This means that the virtual DOM and the real DOM will have one overlapping element.\n     * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param domNode - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects\n     * may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n     * @returns The [[Projection]] that was created.\n     */\n        merge: function (element, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            vnode.domNode = element;\n            initPropertiesAndChildren(element, vnode, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        }\n    };\n    /**\n * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.\n * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.\n * For more information, see [[CalculationCache]].\n *\n * @param <Result> The type of the value that is cached.\n */\n    exports.createCache = function () {\n        var cachedInputs = undefined;\n        var cachedOutcome = undefined;\n        var result = {\n            invalidate: function () {\n                cachedOutcome = undefined;\n                cachedInputs = undefined;\n            },\n            result: function (inputs, calculation) {\n                if (cachedInputs) {\n                    for (var i = 0; i < inputs.length; i++) {\n                        if (cachedInputs[i] !== inputs[i]) {\n                            cachedOutcome = undefined;\n                        }\n                    }\n                }\n                if (!cachedOutcome) {\n                    cachedOutcome = calculation();\n                    cachedInputs = inputs;\n                }\n                return cachedOutcome;\n            }\n        };\n        return result;\n    };\n    /**\n * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\n * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.\n *\n * @param <Source>       The type of source items. A database-record for instance.\n * @param <Target>       The type of target items. A [[Component]] for instance.\n * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.\n * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical\n *                       to the `callback` argument in `Array.map(callback)`.\n * @param updateResult   `function(source, target, index)` that updates a result to an updated source.\n */\n    exports.createMapping = function (getSourceKey, createResult, updateResult) {\n        var keys = [];\n        var results = [];\n        return {\n            results: results,\n            map: function (newSources) {\n                var newKeys = newSources.map(getSourceKey);\n                var oldTargets = results.slice();\n                var oldIndex = 0;\n                for (var i = 0; i < newSources.length; i++) {\n                    var source = newSources[i];\n                    var sourceKey = newKeys[i];\n                    if (sourceKey === keys[oldIndex]) {\n                        results[i] = oldTargets[oldIndex];\n                        updateResult(source, oldTargets[oldIndex], i);\n                        oldIndex++;\n                    } else {\n                        var found = false;\n                        for (var j = 1; j < keys.length + 1; j++) {\n                            var searchIndex = (oldIndex + j) % keys.length;\n                            if (keys[searchIndex] === sourceKey) {\n                                results[i] = oldTargets[searchIndex];\n                                updateResult(newSources[i], oldTargets[searchIndex], i);\n                                oldIndex = searchIndex + 1;\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            results[i] = createResult(source, i);\n                        }\n                    }\n                }\n                results.length = newSources.length;\n                keys = newKeys;\n            }\n        };\n    };\n    /**\n * Creates a [[Projector]] instance using the provided projectionOptions.\n *\n * For more information, see [[Projector]].\n *\n * @param projectionOptions   Options that influence how the DOM is rendered and updated.\n */\n    exports.createProjector = function (projectorOptions) {\n        var projector;\n        var projectionOptions = applyDefaultProjectionOptions(projectorOptions);\n        projectionOptions.eventHandlerInterceptor = function (propertyName, eventHandler, domNode, properties) {\n            return function () {\n                // intercept function calls (event handlers) to do a render afterwards.\n                projector.scheduleRender();\n                return eventHandler.apply(properties.bind || this, arguments);\n            };\n        };\n        var renderCompleted = true;\n        var scheduled;\n        var stopped = false;\n        var projections = [];\n        var renderFunctions = [];\n        // matches the projections array\n        var doRender = function () {\n            scheduled = undefined;\n            if (!renderCompleted) {\n                return;    // The last render threw an error, it should be logged in the browser console.\n            }\n            renderCompleted = false;\n            for (var i = 0; i < projections.length; i++) {\n                var updatedVnode = renderFunctions[i]();\n                projections[i].update(updatedVnode);\n            }\n            renderCompleted = true;\n        };\n        projector = {\n            scheduleRender: function () {\n                if (!scheduled && !stopped) {\n                    scheduled = requestAnimationFrame(doRender);\n                }\n            },\n            stop: function () {\n                if (scheduled) {\n                    cancelAnimationFrame(scheduled);\n                    scheduled = undefined;\n                }\n                stopped = true;\n            },\n            resume: function () {\n                stopped = false;\n                renderCompleted = true;\n                projector.scheduleRender();\n            },\n            append: function (parentNode, renderMaquetteFunction) {\n                projections.push(exports.dom.append(parentNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            insertBefore: function (beforeNode, renderMaquetteFunction) {\n                projections.push(exports.dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            merge: function (domNode, renderMaquetteFunction) {\n                projections.push(exports.dom.merge(domNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            replace: function (domNode, renderMaquetteFunction) {\n                var vnode = renderMaquetteFunction();\n                createDom(vnode, domNode.parentNode, domNode, projectionOptions);\n                domNode.parentNode.removeChild(domNode);\n                projections.push(createProjection(vnode, projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            detach: function (renderMaquetteFunction) {\n                for (var i = 0; i < renderFunctions.length; i++) {\n                    if (renderFunctions[i] === renderMaquetteFunction) {\n                        renderFunctions.splice(i, 1);\n                        return projections.splice(i, 1)[0];\n                    }\n                }\n                throw new Error('renderMaquetteFunction was not found');\n            }\n        };\n        return projector;\n    };\n}));\n//# sourceMappingURL=maquette.js.map\n","'use strict';\n\nvar Executor = require('./executor');\n\nfunction Benchmark() {\n  this.running = false;\n  this.impl = null;\n  this.tests = null;\n  this.reportCallback = null;\n  this.enableTests = false;\n\n  this.container = document.createElement('div');\n\n  this._runButton = document.getElementById('RunButton');\n  this._iterationsElement = document.getElementById('Iterations');\n  this._reportElement = document.createElement('pre');\n\n  document.body.appendChild(this.container);\n  document.body.appendChild(this._reportElement);\n\n  var self = this;\n\n  this._runButton.addEventListener('click', function(e) {\n    e.preventDefault();\n\n    if (!self.running) {\n      var iterations = parseInt(self._iterationsElement.value);\n      if (iterations <= 0) {\n        iterations = 10;\n      }\n\n      self.run(iterations);\n    }\n  }, false);\n\n  this.ready(true);\n}\n\nBenchmark.prototype.ready = function(v) {\n  if (v) {\n    this._runButton.disabled = '';\n  } else {\n    this._runButton.disabled = 'true';\n  }\n};\n\nBenchmark.prototype.run = function(iterations) {\n  var self = this;\n  this.running = true;\n  this.ready(false);\n\n  new Executor(self.impl, self.container, self.tests, 1, function() { // warmup\n    new Executor(self.impl, self.container, self.tests, iterations, function(samples) {\n      self._reportElement.textContent = JSON.stringify(samples, null, ' ');\n      self.running = false;\n      self.ready(true);\n      if (self.reportCallback != null) {\n        self.reportCallback(samples);\n      }\n    }, undefined, false).start();\n  }, undefined, this.enableTests).start();\n};\n\nmodule.exports = Benchmark;\n","'use strict';\n\nfunction render(nodes) {\n  var children = [];\n  var j;\n  var c;\n  var i;\n  var e;\n  var n;\n\n  for (i = 0; i < nodes.length; i++) {\n    n = nodes[i];\n    if (n.children !== null) {\n      e = document.createElement('div');\n      c = render(n.children);\n      for (j = 0; j < c.length; j++) {\n        e.appendChild(c[j]);\n      }\n      children.push(e);\n    } else {\n      e = document.createElement('span');\n      e.textContent = n.key.toString();\n      children.push(e);\n    }\n  }\n\n  return children;\n}\n\nfunction testInnerHtml(testName, nodes, container) {\n  var c = document.createElement('div');\n  var e = document.createElement('div');\n  var children = render(nodes);\n  for (var i = 0; i < children.length; i++) {\n    e.appendChild(children[i]);\n  }\n  c.appendChild(e);\n  if (c.innerHTML !== container.innerHTML) {\n    console.log('error in test: ' + testName);\n    console.log('container.innerHTML:');\n    console.log(container.innerHTML);\n    console.log('should be:');\n    console.log(c.innerHTML);\n  }\n}\n\n\nfunction Executor(impl, container, tests, iterations, cb, iterCb, enableTests) {\n  if (iterCb === void 0) iterCb = null;\n\n  this.impl = impl;\n  this.container = container;\n  this.tests = tests;\n  this.iterations = iterations;\n  this.cb = cb;\n  this.iterCb = iterCb;\n  this.enableTests = enableTests;\n\n  this._currentTest = 0;\n  this._currentIter = 0;\n  this._renderSamples = [];\n  this._updateSamples = [];\n  this._result = [];\n\n  this._tasksCount = tests.length * iterations;\n\n  this._iter = this.iter.bind(this);\n}\n\nExecutor.prototype.start = function() {\n  this._iter();\n};\n\nExecutor.prototype.finished = function() {\n  this.cb(this._result);\n};\n\nExecutor.prototype.progress = function() {\n  if (this._currentTest === 0 && this._currentIter === 0) {\n    return 0;\n  }\n\n  var tests = this.tests;\n  return (this._currentTest * tests.length + this._currentIter) / (tests.length * this.iterataions);\n};\n\nExecutor.prototype.iter = function() {\n  if (this.iterCb != null) {\n    this.iterCb(this);\n  }\n\n  var tests = this.tests;\n\n  if (this._currentTest < tests.length) {\n    var test = tests[this._currentTest];\n\n    if (this._currentIter < this.iterations) {\n      var e, t;\n      var renderTime, updateTime;\n\n      e = new this.impl(this.container, test.data.a, test.data.b);\n      e.setUp();\n\n      t = window.performance.now();\n      e.render();\n      renderTime = window.performance.now() - t;\n\n      if (this.enableTests) {\n        testInnerHtml(test.name + 'render()', test.data.a, this.container);\n      }\n\n      t = window.performance.now();\n      e.update();\n      updateTime = window.performance.now() - t;\n\n      if (this.enableTests) {\n        testInnerHtml(test.name + 'update()', test.data.b, this.container);\n      }\n\n      e.tearDown();\n\n      this._renderSamples.push(renderTime);\n      this._updateSamples.push(updateTime);\n\n      this._currentIter++;\n    } else {\n      this._result.push({\n        name: test.name + ' ' + 'render()',\n        data: this._renderSamples.slice(0)\n      });\n\n      this._result.push({\n        name: test.name + ' ' + 'update()',\n        data: this._updateSamples.slice(0)\n      });\n\n      this._currentTest++;\n\n      this._currentIter = 0;\n      this._renderSamples = [];\n      this._updateSamples = [];\n    }\n\n    setTimeout(this._iter, 0);\n  } else {\n    this.finished();\n  }\n};\n\nmodule.exports = Executor;\n","'use strict';\n\nvar Benchmark = require('./benchmark');\nvar benchmark = new Benchmark();\n\nfunction initFromScript(scriptUrl, impl) {\n  var e = document.createElement('script');\n  e.src = scriptUrl;\n\n  e.onload = function() {\n    benchmark.tests = window.generateBenchmarkData().units;\n    benchmark.ready(true);\n  };\n\n  document.head.appendChild(e);\n}\n\nfunction initFromParentWindow(parent, name, version, id) {\n  window.addEventListener('message', function(e) {\n    var data = e.data;\n    var type = data.type;\n\n    if (type === 'tests') {\n      benchmark.tests = data.data;\n      benchmark.reportCallback = function(samples) {\n        parent.postMessage({\n          type: 'report',\n          data: {\n            name: name,\n            version: version,\n            samples: samples\n          },\n          id: id\n        }, '*');\n      };\n      benchmark.ready(true);\n\n      parent.postMessage({\n        type: 'ready',\n        data: null,\n        id: id\n      }, '*');\n    } else if (type === 'run') {\n      benchmark.run(data.data.iterations);\n    }\n  }, false);\n\n  parent.postMessage({\n    type: 'init',\n    data: null,\n    id: id\n  }, '*');\n}\n\nfunction init(name, version, impl) {\n  // Parse Query String.\n  var qs = (function(a) {\n    if (a == \"\") return {};\n    var b = {};\n    for (var i = 0; i < a.length; ++i) {\n      var p=a[i].split('=', 2);\n      if (p.length == 1) {\n        b[p[0]] = \"\";\n      } else {\n        b[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, \" \"));\n      }\n    }\n    return b;\n  })(window.location.search.substr(1).split('&'));\n\n  if (qs['name'] !== void 0) {\n    name = qs['name'];\n  }\n\n  if (qs['version'] !== void 0) {\n    version = qs['version'];\n  }\n\n  var type = qs['type'];\n\n  if (qs['test'] !== void 0) {\n    benchmark.enableTests = true;\n    console.log('tests enabled');\n  }\n\n  var id;\n  if (type === 'iframe') {\n    id = qs['id'];\n    if (id === void 0) id = null;\n    initFromParentWindow(window.parent, name, version, id);\n  } else if (type === 'window') {\n    if (window.opener != null) {\n      id = qs['id'];\n      if (id === void 0) id = null;\n      initFromParentWindow(window.opener, name, version, id);\n    } else {\n      console.log('Failed to initialize: opener window is NULL');\n    }\n  } else {\n    var testsUrl = qs['data']; // url to the script generating test data\n    if (testsUrl !== void 0) {\n      initFromScript(testsUrl);\n    } else {\n      console.log('Failed to initialize: cannot load tests data');\n    }\n  }\n\n  benchmark.impl = impl;\n}\n\n// performance.now() polyfill\n// https://gist.github.com/paulirish/5438650\n// prepare base perf object\nif (typeof window.performance === 'undefined') {\n  window.performance = {};\n}\nif (!window.performance.now){\n  var nowOffset = Date.now();\n  if (performance.timing && performance.timing.navigationStart) {\n    nowOffset = performance.timing.navigationStart;\n  }\n  window.performance.now = function now(){\n    return Date.now() - nowOffset;\n  };\n}\n\nmodule.exports = init;\n"],"sourceRoot":"/source/"}